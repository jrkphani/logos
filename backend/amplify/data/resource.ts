import { defineData, a } from '@aws-amplify/backend';

/*
Define your data models and authorization rules.
Learn more https://docs.amplify.aws/gen2/build-a-backend/data/data-modeling/
*/
const schema = a.schema({
  /**
   * UserProfile model to store onboarding information and other user-specific preferences.
   * Linked to the authenticated user via owner-based auth on 'id' which will be the user's sub.
   */
  UserProfile: a.model({
    userId: a.string().required(), // Typically the Cognito user 'sub'
    userRole: a.string(), // Optional by default
    preferredDocumentTypes: a.string().array(), // Optional array by default
    // Add other profile fields as needed, e.g., displayName
    // Ensure owner field matches the primary key for owner auth
  })
  .authorization(allow => [
    allow.ownerDefinedIn("userId").to(['create', 'read', 'update', 'delete']),
    allow.groups(['admin']).to(['read', 'update', 'delete']),
  ])
  .identifier(['userId']), // Use userId as the primary key

  /**
   * Document model for storing metadata.
   * Content will be stored in S3, referenced by s3ContentKey.
   */
  Document: a.model({
    // id (PK) is auto-generated by a.model()
    title: a.string().required(),
    // 'owner' field is implicitly added by allow.owner() and stores the user's Cognito sub or username
    s3ContentKey: a.string(), // Optional by default
    isPinned: a.boolean().default(false),
    parentDocumentId: a.id(), // Optional by default
    // Timestamps createdAt and updatedAt are automatically added by a.model()
    // workspaceId: a.id() // Placeholder for future "Teams" feature
    // userRole from UserProfile might be used to derive some access later, but V1 is owner-based for docs
  })
  .authorization(allow => [
    allow.owner().to(['create', 'read', 'update', 'delete']), // Only owner can CRUD their documents
    allow.groups(['admin']).to(['read', 'update', 'delete']),
  ]),

  // V1: Collections will be simple. Definition and entries.
  CollectionDefinition: a.model({
    documentId: a.id().required(), // Which document this collection belongs to
    name: a.string().required(),
    // fieldDefinitions: [{name: string, type: 'TEXT' | 'NUMBER' | 'DATE' | 'CHECKBOX'}]
    fieldDefinitions: a.json().required(), // Store as JSON: [{name: "Task", type: "TEXT"}, {name: "DueDate", type: "DATE"}]
    // owner: a.string() // Implicitly added if using owner auth for collections too
  })
  .authorization(allow => [
    allow.owner().to(['create', 'read', 'update', 'delete']),
    allow.groups(['admin']).to(['read', 'update', 'delete']),
  ]),
  // .identifier(['documentId', 'name']) // Example composite identifier

  CollectionEntry: a.model({
    collectionDefinitionId: a.id().required(),
    // values: {fieldName1: value1, fieldName2: value2}
    values: a.json().required(), // Store entry data as flexible JSON
    linkedSubpageDocumentId: a.id(), // Optional by default
    // owner: a.string()
  })
  .authorization(allow => [
    allow.owner().to(['create', 'read', 'update', 'delete']),
    allow.groups(['admin']).to(['read', 'update', 'delete']),
  ]),

  // V1: SharePermissions for asynchronous document sharing
  SharePermission: a.model({
    documentId: a.id().required(),
    sharedWithUserId: a.string().required(), // Cognito 'sub' of the user it's shared with
    permissionLevel: a.enum(['VIEW', 'EDIT']),
    // owner: a.string() // The owner of the document who created the share
  })
  .authorization(allow => [
    allow.owner().to(['create', 'read', 'update', 'delete']), // Only the document owner can manage shares
    allow.groups(['admin']).to(['read', 'update', 'delete']),
    // Users it's shared with need read access to this permission entry to know they have access
    // This requires more complex auth rules, potentially using custom resolvers or AppSync group auth later.
    // For V1, owner manages. Read access for sharedWithUserId can be handled by GSIs and client logic.
  ])
  .identifier(['documentId', 'sharedWithUserId']) // Composite primary key

});

export type Schema = typeof schema; // This exports the Schema type for client-side use

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'userPool', // Use Cognito User Pools for auth
  },
});

/*== STEP 2 ===============================================================
Go to your frontend source code. From your client-side code, generate a
Data client to make CRUDL requests to your table. (THIS SNIPPET WILL ONLY
WORK IN THE FRONTEND CODE FILE.)

Using JavaScript or Next.js React Server Components, Middleware, Server 
Actions or Pages Router? Review how to generate Data clients for those use
cases: https://docs.amplify.aws/gen2/build-a-backend/data/connect-to-API/
=========================================================================*/

/*
"use client"
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource";

const client = generateClient<Schema>() // use this Data client for CRUDL requests
*/

/*== STEP 3 ===============================================================
Fetch records from the database and use them in your frontend component.
(THIS SNIPPET WILL ONLY WORK IN THE FRONTEND CODE FILE.)
=========================================================================*/

/* For example, in a React component, you can use this snippet in your
  function's RETURN statement */
// const { data: todos } = await client.models.Todo.list()

// return <ul>{todos.map(todo => <li key={todo.id}>{todo.content}</li>)}</ul>
